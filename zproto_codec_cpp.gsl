.template 0

include "zproto_lib.gsl"
include "zproto_bnf.gsl"
resolve_includes ()
expand_headers ()
generate_bnf ()
set_defaults ()
.endtemplate
.output "$(class.package_dir)/$(class.name).h"

/*  =========================================================================
    $(class.name) - $(class.title:)

    Codec header for $(class.name).

    ** WARNING *************************************************************
    THIS SOURCE FILE IS 100% GENERATED. If you edit this file, you will lose
    your changes at the next build cycle. This is great for temporary printf
    statements. DO NOT MAKE ANY CHANGES YOU WISH TO KEEP. The correct places
    for commits are:

     * The XML model used for this code generation: $(filename), or
     * The code generation script that built this file: $(script)
    ************************************************************************
.   for class.license
    $(string.trim (license.):block                                         )
.   endfor
    =========================================================================
*/

#ifndef $(CLASS.NAME)_H_INCLUDED
#define $(CLASS.NAME)_H_INCLUDED

using frame = zmq::message_t;
using frames = std::vector<frame>;

class buffer
{
public:
    buffer(zmq::message_t &msg)
        : needle_(static_cast<uint8_t*>(msg.data()))
    {}

    template<typename T, std::size_t N>
    friend buffer& operator<<(buffer &b, const std::array<T,N> &host);

    template<typename T>
    friend buffer& operator<<(buffer &b, const T &host);

    template<typename T, size_t N>
    friend buffer& operator<<(buffer &b, T(&host)[N]);

private:
    uint8_t *needle_;
};

template<typename T>
buffer& operator<<(buffer &b, const T &host)
{
    static_assert(sizeof(uint8_t), sizeof(T));
    b << static_cast<uint32_t>(host.size());
    b.needle_ + 4;
    std::copy(std::begin(host), std::end(host), b.needle_);
    b.needle_ += host.size();
}

template<>
buffeer& operator<uint8_t><<(buffer &b, const uint8_t &host)
{
    *b.needle_ = host;
    ++b.needle_;
}

template<>
buffer& operator<uint16_t><<(buffer &b, const uint16_t &host)
{
    b.needle_[0] = (uint8_t)((host >> 8) & 0xFF);
    b.needle_[1] = (uint8_t)((host)      & 0xFF);
    b.needle_ += 2;
}

template<>
buffer& operator<uint32_t><<(buffer &b, const uint32_t &host)
{
    b.needle_[0] = (uint8_t)((host >> 24) & 0xFF);
    b.needle_[1] = (uint8_t)((host >> 16) & 0xFF);
    b.needle_[2] = (uint8_t)((host >>  8) & 0xFF);
    b.needle_[3] = (uint8_t)((host)       & 0xFF);
    b.needle_ += 4;
}

template<>
buffer& operator<uint64_t><<(buffer &b, const uint64_t &host)
{
    b.needle_[0] = (uint8_t)((host >> 56) & 0xFF);
    b.needle_[1] = (uint8_t)((host >> 48) & 0xFF);
    b.needle_[2] = (uint8_t)((host >> 40) & 0xFF);
    b.needle_[3] = (uint8_t)((host >> 32) & 0xFF);
    b.needle_[4] = (uint8_t)((host >> 24) & 0xFF);
    b.needle_[5] = (uint8_t)((host >> 16) & 0xFF);
    b.needle_[6] = (uint8_t)((host >>  8) & 0xFF);
    b.needle_[7] = (uint8_t)((host)       & 0xFF);
    b.needle_ += 8;
}

template<>
buffer& operator<<<std::vector<std::string>>(buffer &b, const std::vector<uint8_t> &host)
{
    b << static_cast<uint32_t>(host.size());
    for (const auto &s : hosts)
        b << s;
}

template<>
buffer& operator<<<std::unordered_map<std::string, std::string>>(buffer &b, const std::vector<uint8_t> &host)
{
    b << static_cast<uint32_t>(host.size());
    for (const auto &s : hosts) {
        b << static_cast<uint8_t>(s.first.size());
        b << s.first;
        b << static_cast<uint32_t>(s.second.size());
        b << s.second;
    }
}

template<typename T, std::size_t N>
buffer& operator<<(buffer &b, const std::array<T,N> &host)
{
    static_assert(sizeof(uint8_t), sizeof(T));
    std::copy(std::begin(host), std::end(host), b.needle_);
    b.needle_ += N;
}

template<>
buffer& operator<<(buffer &b, const std::array<char,256> &host)
{
    std::size_t size = std::strlen(host.data());
    b << (uint8_t)size;
    std::copy(std::begin(host), std::next(std::begin(host), size), b.needle_);
    b.needle_ += size;
}

.for class.message
class Msg$(message.name:Pascal)
{
public:
.   for message.field where defined (value)
    // Get $(name)
.   if type = "number"
.   if ctype = "byte"
    uint8_t $(name)() const {
        return $(name)_;
    }
.   else
    $(ctype) $(name)() const {
        return $(name)_;
    }
.   endif
.   elsif type = "string"
    std::array<char, 256>& $(name)() const {
        return $(name)_;
    }
.   endif
.   endfor

.   for message.field
.   if type = "number" & !defined (field.value)
    // Get & Set $(name)
.   if ctype = "byte"
    uint8_t $(name)() const {
        return $(name)_;
    }
    void set_$(name)(uint8_t $(name)) {
        $(name)_ = $(name);
    }
.   else
    $(ctype) $(name)() const {
        return $(name)_;
    }
    void set_$(name)($(ctype) $(name)) {
        $(name)_ = $(name);
    }
.   endif
.   elsif type = "octets"
    // Get & Set $(name)
    std::array<uint8_t, $(size)>& $(name)() const {
        return $(name)_;
    }
    void set_$(name)(const std::array<uint8_t, $(size)>& $(name)) {
        $(name)_ = $(name);
    }
.   elsif type = "string" & !defined (field.value)
    // Get & Set $(name)
    std::array<char, 256>& $(name)() const {
        return $(name)_;
    }
    void set_$(name)(const std::array<char, 256>& $(name)) {
        $(name)_ = $(name);
    }
.   elsif type = "longstr"
    // Get & Set $(name)
    std::string& $(name)() const {
        return $(name)_;
    }
    void set_$(name)(const std::string& $(name)) {
        $(name)_ = $(name);
    }
.   elsif type = "strings"
    // Get & Set $(name)
    std::vector<std::string>& $(name)() const {
        return $(name)_;
    }
    void set_$(name)(const std::vector<std::string>& $(name)) {
        $(name)_ = $(name);
    }
.   elsif type = "hash"
    // Get & Set $(name)
    std::unordered_map<std::string, std::string>& $(name)() const {
        return $(name)_;
    }
    void set_$(name)(const std::unordered_map<std::string, std::string>& $(name)) {
        $(name)_ = $(name);
    }
.   elsif type = "uuid"
    // Get & Set $(name)
    std::array<uint8_t, 16>& $(name)() const {
        return $(name)_;
    }
    void set_$(name)(const std::array<uint8_t, 16>& $(name)) {
        $(name)_ = $(name);
    }
.   elsif type = "chunk"
    // Get & Set $(name)
    std::vector<uint8_t>& $(name)() const {
        return $(name)_;
    }
    void set_$(name)(const std::vector<uint8_t>& $(name)) {
        $(name)_ = $(name);
    }
.   elsif type = "frame"
    // Get & Set $(name)
    frame& $(name)() const {
        return $(name)_;
    }
    void set_$(name)(const frame& $(name)) {
        $(name)_ = $(name);
    }
.   elsif type = "msg"
    // Get & Set $(name)
    frames& $(name)() const {
        return $(name)_;
    }
    void set_$(name)(const frames& $(name)) {
        $(name)_ = $(name);
    }
.   endif
.   endfor

private:
.   for message.field
.   if type = "number" & !defined (field.value)
.   if ctype = "byte"
    uint8_t $(name)_;                     //  $(string.trim (field.)?name:left,block)
.   else 
    $(ctype) $(name)_;                    //  $(string.trim (field.)?name:left,block)
.   endif
.   elsif type = "octets"
    std::array<uint8_t, $(size)> $(name)_;      //  $(string.trim (field.)?name:left,block)
.   elsif type = "string" & !defined (field.value)
    std::array<char, 256> $(name)_;       //  $(string.trim (field.)?name:left,block)
.   elsif type = "longstr"
    std::string $(name)_;                 //  $(string.trim (field.)?name:left,block)
.   elsif type = "strings"
    std::vector<std::string> $(name)_;    //  $(string.trim (field.)?name:left,block)
.   elsif type = "hash"
    std::unordered_map<std::string, std::string> $(name)_;         //  $(string.trim (field.)?name:left,block)
.   elsif type = "uuid"
    std::array<uint8_t, 16> $(name)_;     //  $(string.trim (field.)?name:left,block)
.   elsif type = "chunk"
    std::vector<uint8_t> $(name)_;        //  $(string.trim (field.)?name:left,block)
.   elsif type = "frame"
    frame $(name)_;                       //  $(string.trim (field.)?name:left,block)
.   elsif type = "msg"
    frames $(name)_;                      //  $(string.trim (field.)?name:left,block)
.   endif
.   endfor
};

frames& operator<<(frames &f, const Msg$(message.name:Pascal) &m)
{
    size_t frame_size = 0;
.   for message.field
.   if type = "number" 
    frame_size += $(size);      // $(name)
.   elsif type = "octets"
    frame_size += $(size);      // $(name)
.   elsif type = "string"
    frame_size += 1 + std::strlen(m.$(name)_.data()); // $(name)
.   elsif type = "longstr"
    frame_size += 4 + m.$(name)_.size(); // $(name)
.   elsif type = "strings"
    frame_size += 4;            // $(name)
    for (const auto &s : m.$(name)_)
        frame_size += 4 + s.size();
.   elsif type = "hash"
    frame_size += 4;            // $(name)
    for (const auto &p : m.$(name)_)
        frame_size += 1 + p.first.size() + 4 + p.second.size();
.   elsif type = "uuid"
    frame_size += 16;           // $(name)
.   elsif type = "chunk"
    frame_size += 4 + m.$(name)_.size();  // $(name)
.   elsif type = "frame"
.   elsif type = "msg"
.       class.msg = name
.       if item () <> count (message.field)
.           echo "E: in $(message.name:), $(field.name) must come last"
.       endif
.   endif
.   endfor
    frame f(frame_size);
}

.endfor

#endif
